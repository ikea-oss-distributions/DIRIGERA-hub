From 69911b18f94bb32fd3592745d5fdead473e76103 Mon Sep 17 00:00:00 2001
From: Romuald JEANNE <romuald.jeanne@st.com>
Date: Tue, 16 Mar 2021 08:16:59 +0100
Subject: [PATCH 1/5] ARM v2020.10-stm32mp-r1 MACHINE

Signed-off-by: Romuald JEANNE <romuald.jeanne@st.com>
---
 .gitignore                                    |  3 +
 CONTRIBUTING.md                               | 30 ++++++
 Makefile                                      |  2 +-
 arch/arc/include/asm/config.h                 |  2 -
 arch/arm/include/asm/config.h                 |  1 -
 arch/arm/include/asm/system.h                 |  3 +
 arch/arm/lib/cache-cp15.c                     | 35 +++++--
 arch/arm/mach-stm32mp/Kconfig                 | 38 +++----
 arch/arm/mach-stm32mp/Makefile                |  2 +-
 arch/arm/mach-stm32mp/bsec.c                  | 10 ++
 arch/arm/mach-stm32mp/cmd_stm32prog/Kconfig   | 34 +++++++
 arch/arm/mach-stm32mp/cmd_stm32prog/Makefile  |  8 +-
 .../cmd_stm32prog/cmd_stm32prog.c             | 25 ++---
 .../mach-stm32mp/cmd_stm32prog/stm32prog.c    | 66 +++++++++----
 .../mach-stm32mp/cmd_stm32prog/stm32prog.h    | 36 ++++++-
 .../cmd_stm32prog/stm32prog_serial.c          | 53 ++++------
 arch/arm/mach-stm32mp/config.mk               |  2 +-
 arch/arm/mach-stm32mp/cpu.c                   | 30 +++---
 arch/arm/mach-stm32mp/fdt.c                   | 11 ++-
 arch/arm/mach-stm32mp/include/mach/stm32.h    |  2 +
 .../mach-stm32mp/include/mach/stm32mp1_smc.h  | 50 +++++++---
 .../arm/mach-stm32mp/include/mach/stm32prog.h |  1 +
 arch/arm/mach-stm32mp/pwr_regulator.c         |  5 +
 arch/arm/mach-stm32mp/spl.c                   |  5 +-
 arch/m68k/include/asm/config.h                |  1 -
 arch/microblaze/include/asm/config.h          |  2 -
 arch/mips/include/asm/config.h                |  1 -
 arch/nds32/include/asm/config.h               |  1 -
 arch/powerpc/include/asm/config.h             |  1 -
 arch/riscv/include/asm/config.h               |  1 -
 arch/riscv/lib/fdt_fixup.c                    |  2 +-
 arch/sandbox/dts/test.dts                     | 37 +++++++
 arch/sandbox/include/asm/scmi_test.h          | 99 +++++++++++++++++++
 arch/sh/include/asm/config.h                  |  2 -
 arch/x86/include/asm/config.h                 |  1 -
 arch/xtensa/include/asm/config.h              |  2 -
 36 files changed, 460 insertions(+), 144 deletions(-)
 create mode 100644 CONTRIBUTING.md
 create mode 100644 arch/arm/mach-stm32mp/cmd_stm32prog/Kconfig
 create mode 100644 arch/sandbox/include/asm/scmi_test.h

diff --git a/.gitignore b/.gitignore
index e66aa864da..a489ae7874 100644
--- a/.gitignore
+++ b/.gitignore
@@ -95,3 +95,6 @@ GTAGS
 
 # Python cache
 __pycache__
+
+/oe-*
+bitbake-cookerdaemon.log
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
new file mode 100644
index 0000000000..3d1bacd78a
--- /dev/null
+++ b/CONTRIBUTING.md
@@ -0,0 +1,30 @@
+ï»¿# Contributing guide
+
+This document serves as a checklist before contributing to this repository. It includes links to read up on if topics are unclear to you.
+
+This guide mainly focuses on the proper use of Git.
+
+## 1. Issues
+
+STM32MPU projects do not activate "Github issues" feature for the time being. If you need to report an issue or question about this project deliverables, you can report them using [ ST Support Center ](https://my.st.com/ols#/ols/newrequest)  or  [ ST Community MPU Forum ](https://community.st.com/s/topic/0TO0X0000003u2AWAQ/stm32-mpus).
+
+## 2. Pull Requests
+
+STMicrolectronics is happy to receive contributions from the community, based on an initial Contributor License Agreement (CLA) procedure.
+
+* If you are an individual writing original source code and you are sure **you own the intellectual property**, then you need to sign an Individual CLA (https://cla.st.com).
+* If you work for a company that wants also to allow you to contribute with your work, your company needs to provide a Corporate CLA (https://cla.st.com) mentioning your GitHub account name.
+* If you are not sure that a CLA (Individual or Corporate) has been signed for your GitHub account you can check here (https://cla.st.com).
+
+Please note that:
+* The Corporate CLA will always take precedence over the Individual CLA.
+* One CLA submission is sufficient, for any project proposed by STMicroelectronics.
+
+__How to proceed__
+
+* We recommend to fork the project in your GitHub account to further develop your contribution. Please use the latest commit version.
+* Please, submit one Pull Request for one new feature or proposal. This will ease the analysis and final merge if accepted.
+
+__Note__
+
+Merge will not be done directly in GitHub but it will need first to follow internal integration process before public deliver in a standard release. The Pull request will stay open until it is merged and delivered.
diff --git a/Makefile b/Makefile
index d4736bb501..6bd0841c4b 100644
--- a/Makefile
+++ b/Makefile
@@ -3,7 +3,7 @@
 VERSION = 2020
 PATCHLEVEL = 10
 SUBLEVEL =
-EXTRAVERSION =
+EXTRAVERSION = -stm32mp-r1
 NAME =
 
 # *DOCUMENTATION*
diff --git a/arch/arc/include/asm/config.h b/arch/arc/include/asm/config.h
index d88c361488..46e94be141 100644
--- a/arch/arc/include/asm/config.h
+++ b/arch/arc/include/asm/config.h
@@ -8,6 +8,4 @@
 
 #define CONFIG_SYS_BOOT_RAMDISK_HIGH
 
-#define CONFIG_LMB
-
 #endif /*__ASM_ARC_CONFIG_H_ */
diff --git a/arch/arm/include/asm/config.h b/arch/arm/include/asm/config.h
index bf692ce279..14860d89b6 100644
--- a/arch/arm/include/asm/config.h
+++ b/arch/arm/include/asm/config.h
@@ -6,7 +6,6 @@
 #ifndef _ASM_CONFIG_H_
 #define _ASM_CONFIG_H_
 
-#define CONFIG_LMB
 #define CONFIG_SYS_BOOT_RAMDISK_HIGH
 
 #if defined(CONFIG_ARCH_LS1021A) || \
diff --git a/arch/arm/include/asm/system.h b/arch/arm/include/asm/system.h
index ce552944b7..932f12af1c 100644
--- a/arch/arm/include/asm/system.h
+++ b/arch/arm/include/asm/system.h
@@ -458,6 +458,7 @@ static inline void set_dacr(unsigned int val)
 
 /* options available for data cache on each page */
 enum dcache_option {
+	INVALID_ENTRY = 0,
 	DCACHE_OFF = TTB_SECT | TTB_SECT_MAIR(0) | TTB_SECT_XN_MASK,
 	DCACHE_WRITETHROUGH = TTB_SECT | TTB_SECT_MAIR(1),
 	DCACHE_WRITEBACK = TTB_SECT | TTB_SECT_MAIR(2),
@@ -488,6 +489,7 @@ enum dcache_option {
  *   1    1  1   Outer/Inner Write-Back, Read-Allocate Write-Allocate
  */
 enum dcache_option {
+	INVALID_ENTRY = 0,
 	DCACHE_OFF = TTB_SECT_DOMAIN(0) | TTB_SECT_XN_MASK | TTB_SECT,
 	DCACHE_WRITETHROUGH = DCACHE_OFF | TTB_SECT_C_MASK,
 	DCACHE_WRITEBACK = DCACHE_WRITETHROUGH | TTB_SECT_B_MASK,
@@ -497,6 +499,7 @@ enum dcache_option {
 #define TTB_SECT_AP		(3 << 10)
 /* options available for data cache on each page */
 enum dcache_option {
+	INVALID_ENTRY = 0,
 	DCACHE_OFF = 0x12,
 	DCACHE_WRITETHROUGH = 0x1a,
 	DCACHE_WRITEBACK = 0x1e,
diff --git a/arch/arm/lib/cache-cp15.c b/arch/arm/lib/cache-cp15.c
index abd81d21c7..94e9b9c861 100644
--- a/arch/arm/lib/cache-cp15.c
+++ b/arch/arm/lib/cache-cp15.c
@@ -6,6 +6,7 @@
 
 #include <common.h>
 #include <cpu_func.h>
+#include <lmb.h>
 #include <log.h>
 #include <asm/system.h>
 #include <asm/cache.h>
@@ -96,27 +97,33 @@ void mmu_set_region_dcache_behaviour_phys(phys_addr_t start, phys_addr_t phys,
 	mmu_page_table_flush(startpt, stoppt);
 }
 
-void mmu_set_region_dcache_behaviour(phys_addr_t start, size_t size,
-				     enum dcache_option option)
-{
-	mmu_set_region_dcache_behaviour_phys(start, start, size, option);
-}
-
 __weak void dram_bank_mmu_setup(int bank)
 {
 	struct bd_info *bd = gd->bd;
+	struct lmb lmb;
 	int	i;
 
 	/* bd->bi_dram is available only after relocation */
 	if ((gd->flags & GD_FLG_RELOC) == 0)
 		return;
 
+	/*
+	 * don't allow cache on reserved memory tagged 'no-map' in DT
+	 * => avoid speculative access to "secure" data
+	 */
+	lmb_init_and_reserve(&lmb, bd, (void *)gd->fdt_blob);
+
 	debug("%s: bank: %d\n", __func__, bank);
 	for (i = bd->bi_dram[bank].start >> MMU_SECTION_SHIFT;
 	     i < (bd->bi_dram[bank].start >> MMU_SECTION_SHIFT) +
 		 (bd->bi_dram[bank].size >> MMU_SECTION_SHIFT);
-	     i++)
-		set_section_dcache(i, DCACHE_DEFAULT_OPTION);
+	     i++) {
+		if (lmb_is_reserved_flags(&lmb, i << MMU_SECTION_SHIFT,
+					  LMB_NOMAP))
+			set_section_dcache(i, INVALID_ENTRY);
+		else
+			set_section_dcache(i, DCACHE_DEFAULT_OPTION);
+	}
 }
 
 /* to activate the MMU we need to set up virtual memory: use 1M areas */
@@ -313,6 +320,12 @@ int dcache_status(void)
 {
 	return 0;					/* always off */
 }
+
+void mmu_set_region_dcache_behaviour(phys_addr_t start, size_t size,
+				     enum dcache_option option)
+{
+}
+
 #else
 void dcache_enable(void)
 {
@@ -328,4 +341,10 @@ int dcache_status(void)
 {
 	return (get_cr() & CR_C) != 0;
 }
+
+void mmu_set_region_dcache_behaviour(phys_addr_t start, size_t size,
+				     enum dcache_option option)
+{
+	mmu_set_region_dcache_behaviour_phys(start, start, size, option);
+}
 #endif
diff --git a/arch/arm/mach-stm32mp/Kconfig b/arch/arm/mach-stm32mp/Kconfig
index 478fd2f17d..af0246d031 100644
--- a/arch/arm/mach-stm32mp/Kconfig
+++ b/arch/arm/mach-stm32mp/Kconfig
@@ -56,6 +56,13 @@ config STM32MP15x
 		dual core A7 for STM32MP157/3, monocore for STM32MP151
 		target all the STMicroelectronics board with SOC STM32MP1 family
 
+config STM32MP15x_STM32IMAGE
+	bool "Support STM32 image for generated U-Boot image"
+	depends on STM32MP15x && TFABOOT
+	help
+		Support of STM32 image generation for SOC STM32MP15x
+		for TF-A boot when FIP container is not used
+
 choice
 	prompt "STM32MP15x board select"
 	optional
@@ -93,6 +100,19 @@ config SYS_TEXT_BASE
 config NR_DRAM_BANKS
 	default 1
 
+config DDR_CACHEABLE_SIZE
+	hex "Size of the DDR marked cacheable in pre-reloc stage"
+	default 0x10000000 if TFABOOT
+	default 0x40000000
+	help
+		Define the size of the DDR marked as cacheable in U-Boot
+		pre-reloc stage.
+		This option can be useful to avoid speculatif access
+		to secured area of DDR used by TF-A or OP-TEE before U-Boot
+		initialization.
+		The areas marked "no-map" in device tree should be located
+		before this limit: STM32_DDR_BASE + DDR_CACHEABLE_SIZE.
+
 config SYS_MMCSD_RAW_MODE_U_BOOT_PARTITION_MMC2
 	hex "Partition on MMC2 to use to load U-Boot from"
 	depends on SYS_MMCSD_RAW_MODE_U_BOOT_USE_PARTITION
@@ -108,23 +128,6 @@ config STM32_ETZPC
 	help
 	  Say y to enable STM32 Extended TrustZone Protection
 
-config CMD_STM32PROG
-	bool "command stm32prog for STM32CudeProgrammer"
-	select DFU
-	select DFU_RAM
-	select DFU_VIRT
-	select PARTITION_TYPE_GUID
-	imply CMD_GPT if MMC
-	imply CMD_MTD if MTD
-	imply DFU_MMC if MMC
-	imply DFU_MTD if MTD
-	help
-		activate a specific command stm32prog for STM32MP soc family
-		witch update the device with the tools STM32CubeProgrammer,
-		using UART with STM32 protocol or USB with DFU protocol
-		NB: access to not volatile memory (NOR/NAND/SD/eMMC) is based
-		    on U-Boot DFU framework
-
 config CMD_STM32KEY
 	bool "command stm32key to fuse public key hash"
 	default y
@@ -164,6 +167,7 @@ config DEBUG_UART_CLOCK
 	default 64000000
 endif
 
+source "arch/arm/mach-stm32mp/cmd_stm32prog/Kconfig"
 source "board/st/stm32mp1/Kconfig"
 source "board/dhelectronics/dh_stm32mp1/Kconfig"
 
diff --git a/arch/arm/mach-stm32mp/Makefile b/arch/arm/mach-stm32mp/Makefile
index c8aa24d489..aa39867080 100644
--- a/arch/arm/mach-stm32mp/Makefile
+++ b/arch/arm/mach-stm32mp/Makefile
@@ -11,7 +11,7 @@ obj-y += bsec.o
 ifdef CONFIG_SPL_BUILD
 obj-y += spl.o
 else
-obj-$(CONFIG_CMD_STM32PROG) += cmd_stm32prog/
+obj-y += cmd_stm32prog/
 obj-$(CONFIG_CMD_STM32KEY) += cmd_stm32key.o
 obj-$(CONFIG_ARMV7_PSCI) += psci.o
 obj-$(CONFIG_TFABOOT) += boot_params.o
diff --git a/arch/arm/mach-stm32mp/bsec.c b/arch/arm/mach-stm32mp/bsec.c
index a9b9bd0902..3583368a91 100644
--- a/arch/arm/mach-stm32mp/bsec.c
+++ b/arch/arm/mach-stm32mp/bsec.c
@@ -4,6 +4,7 @@
  */
 
 #include <common.h>
+#include <clk.h>
 #include <dm.h>
 #include <log.h>
 #include <misc.h>
@@ -486,6 +487,15 @@ static int stm32mp_bsec_probe(struct udevice *dev)
 {
 	int otp;
 	struct stm32mp_bsec_platdata *plat;
+	struct clk_bulk clk_bulk;
+	int ret;
+
+	ret = clk_get_bulk(dev, &clk_bulk);
+	if (!ret) {
+		ret = clk_enable_bulk(&clk_bulk);
+		if (ret)
+			return ret;
+	}
 
 	/*
 	 * update unlocked shadow for OTP cleared by the rom code
diff --git a/arch/arm/mach-stm32mp/cmd_stm32prog/Kconfig b/arch/arm/mach-stm32mp/cmd_stm32prog/Kconfig
new file mode 100644
index 0000000000..f4c0d18d4d
--- /dev/null
+++ b/arch/arm/mach-stm32mp/cmd_stm32prog/Kconfig
@@ -0,0 +1,34 @@
+
+config CMD_STM32PROG
+	bool "command stm32prog for STM32CudeProgrammer"
+	select DFU
+	select DFU_RAM
+	select DFU_VIRT
+	select PARTITION_TYPE_GUID
+	imply CMD_GPT if MMC
+	imply CMD_MTD if MTD
+	imply DFU_MMC if MMC
+	imply DFU_MTD if MTD
+	help
+		activate a specific command stm32prog for STM32MP soc family
+		witch update the device with the tools STM32CubeProgrammer
+		NB: access to not volatile memory (NOR/NAND/SD/eMMC) is based
+		    on U-Boot DFU framework
+
+config CMD_STM32PROG_USB
+	bool "support stm32prog over USB"
+	depends on CMD_STM32PROG
+	default y
+	help
+		activate the command "stm32prog usb" for STM32MP soc family
+		witch update the device with the tools STM32CubeProgrammer,
+		using USB with DFU protocol
+
+config CMD_STM32PROG_SERIAL
+	bool "support stm32prog over UART"
+	depends on CMD_STM32PROG
+	default y
+	help
+		activate the command "stm32prog serial" for STM32MP soc family
+		with the tools STM32CubeProgrammer using U-Boot serial device
+		and UART protocol.
\ No newline at end of file
diff --git a/arch/arm/mach-stm32mp/cmd_stm32prog/Makefile b/arch/arm/mach-stm32mp/cmd_stm32prog/Makefile
index 548a378921..b57e1bf870 100644
--- a/arch/arm/mach-stm32mp/cmd_stm32prog/Makefile
+++ b/arch/arm/mach-stm32mp/cmd_stm32prog/Makefile
@@ -3,7 +3,7 @@
 # Copyright (C) 2020, STMicroelectronics - All Rights Reserved
 #
 
-obj-y += cmd_stm32prog.o
-obj-y += stm32prog.o
-obj-y += stm32prog_serial.o
-obj-y += stm32prog_usb.o
+obj-$(CONFIG_CMD_STM32PROG) += cmd_stm32prog.o
+obj-$(CONFIG_CMD_STM32PROG) += stm32prog.o
+obj-$(CONFIG_CMD_STM32PROG_SERIAL) += stm32prog_serial.o
+obj-$(CONFIG_CMD_STM32PROG_USB) += stm32prog_usb.o
diff --git a/arch/arm/mach-stm32mp/cmd_stm32prog/cmd_stm32prog.c b/arch/arm/mach-stm32mp/cmd_stm32prog/cmd_stm32prog.c
index 49dd25b28f..a20980a6ae 100644
--- a/arch/arm/mach-stm32mp/cmd_stm32prog/cmd_stm32prog.c
+++ b/arch/arm/mach-stm32mp/cmd_stm32prog/cmd_stm32prog.c
@@ -50,9 +50,9 @@ static int do_stm32prog(struct cmd_tbl *cmdtp, int flag, int argc,
 	if (argc < 3 ||  argc > 5)
 		return CMD_RET_USAGE;
 
-	if (!strcmp(argv[1], "usb"))
+	if (IS_ENABLED(CONFIG_CMD_STM32PROG_USB) && !strcmp(argv[1], "usb"))
 		link = LINK_USB;
-	else if (!strcmp(argv[1], "serial"))
+	else if (IS_ENABLED(CONFIG_CMD_STM32PROG_SERIAL) && !strcmp(argv[1], "serial"))
 		link = LINK_SERIAL;
 
 	if (link == LINK_UNDEFINED) {
@@ -73,15 +73,16 @@ static int do_stm32prog(struct cmd_tbl *cmdtp, int flag, int argc,
 		size = simple_strtoul(argv[4], NULL, 16);
 
 	/* check STM32IMAGE presence */
-	if (size == 0 &&
-	    !stm32prog_header_check((struct raw_header_s *)addr, &header)) {
-		size = header.image_length + BL_HEADER_SIZE;
-
-		/* uImage detected in STM32IMAGE, execute the script */
-		if (IMAGE_FORMAT_LEGACY ==
-		    genimg_get_format((void *)(addr + BL_HEADER_SIZE)))
-			return image_source_script(addr + BL_HEADER_SIZE,
-						   "script@1");
+	if (size == 0) {
+		stm32prog_header_check((struct raw_header_s *)addr, &header);
+		if (header.type == HEADER_STM32IMAGE) {
+			size = header.image_length + BL_HEADER_SIZE;
+
+			/* uImage detected in STM32IMAGE, execute the script */
+			if (IMAGE_FORMAT_LEGACY ==
+			    genimg_get_format((void *)(addr + BL_HEADER_SIZE)))
+				return image_source_script(addr + BL_HEADER_SIZE, "script@1");
+		}
 	}
 
 	if (IS_ENABLED(CONFIG_DM_VIDEO))
@@ -174,6 +175,7 @@ U_BOOT_CMD(stm32prog, 5, 0, do_stm32prog,
 	   "<size> = size of flashlayout\n"
 );
 
+#ifdef CONFIG_STM32MP15x_STM32IMAGE
 bool stm32prog_get_tee_partitions(void)
 {
 	if (stm32prog_data)
@@ -181,6 +183,7 @@ bool stm32prog_get_tee_partitions(void)
 
 	return false;
 }
+#endif
 
 bool stm32prog_get_fsbl_nor(void)
 {
diff --git a/arch/arm/mach-stm32mp/cmd_stm32prog/stm32prog.c b/arch/arm/mach-stm32mp/cmd_stm32prog/stm32prog.c
index ec3355d816..627bb52a11 100644
--- a/arch/arm/mach-stm32mp/cmd_stm32prog/stm32prog.c
+++ b/arch/arm/mach-stm32mp/cmd_stm32prog/stm32prog.c
@@ -59,8 +59,6 @@ static const efi_guid_t uuid_mmc[3] = {
 	ROOTFS_MMC2_UUID
 };
 
-DECLARE_GLOBAL_DATA_PTR;
-
 /* order of column in flash layout file */
 enum stm32prog_col_t {
 	COL_OPTION,
@@ -72,6 +70,16 @@ enum stm32prog_col_t {
 	COL_NB_STM32
 };
 
+#define FIP_TOC_HEADER_NAME	0xAA640001
+
+struct fip_toc_header {
+	u32	name;
+	u32	serial_number;
+	u64	flags;
+};
+
+DECLARE_GLOBAL_DATA_PTR;
+
 /* partition handling routines : CONFIG_CMD_MTDPARTS */
 int mtdparts_init(void);
 int find_dev_and_part(const char *id, struct mtd_device **dev,
@@ -87,46 +95,57 @@ char *stm32prog_get_error(struct stm32prog_data *data)
 	return data->error;
 }
 
-u8 stm32prog_header_check(struct raw_header_s *raw_header,
-			  struct image_header_s *header)
+static bool stm32prog_is_fip_header(struct fip_toc_header *header)
+{
+	return (header->name == FIP_TOC_HEADER_NAME) && header->serial_number;
+}
+
+void stm32prog_header_check(struct raw_header_s *raw_header,
+			    struct image_header_s *header)
 {
 	unsigned int i;
 
-	header->present = 0;
+	if (!raw_header || !header) {
+		pr_debug("%s:no header data\n", __func__);
+		return;
+	}
+
+	header->type = HEADER_NONE;
 	header->image_checksum = 0x0;
 	header->image_length = 0x0;
 
-	if (!raw_header || !header) {
-		pr_debug("%s:no header data\n", __func__);
-		return -1;
+	if (stm32prog_is_fip_header((struct fip_toc_header *)raw_header)) {
+		header->type = HEADER_FIP;
+		return;
 	}
+
 	if (raw_header->magic_number !=
 		(('S' << 0) | ('T' << 8) | ('M' << 16) | (0x32 << 24))) {
 		pr_debug("%s:invalid magic number : 0x%x\n",
 			 __func__, raw_header->magic_number);
-		return -2;
+		return;
 	}
 	/* only header v1.0 supported */
 	if (raw_header->header_version != 0x00010000) {
 		pr_debug("%s:invalid header version : 0x%x\n",
 			 __func__, raw_header->header_version);
-		return -3;
+		return;
 	}
 	if (raw_header->reserved1 != 0x0 || raw_header->reserved2) {
 		pr_debug("%s:invalid reserved field\n", __func__);
-		return -4;
+		return;
 	}
 	for (i = 0; i < (sizeof(raw_header->padding) / 4); i++) {
 		if (raw_header->padding[i] != 0) {
 			pr_debug("%s:invalid padding field\n", __func__);
-			return -5;
+			return;
 		}
 	}
-	header->present = 1;
+	header->type = HEADER_STM32IMAGE;
 	header->image_checksum = le32_to_cpu(raw_header->image_checksum);
 	header->image_length = le32_to_cpu(raw_header->image_length);
 
-	return 0;
+	return;
 }
 
 static u32 stm32prog_header_checksum(u32 addr, struct image_header_s *header)
@@ -355,8 +374,8 @@ static int parse_flash_layout(struct stm32prog_data *data,
 	data->part_nb = 0;
 
 	/* check if STM32image is detected */
-	if (!stm32prog_header_check((struct raw_header_s *)addr,
-				    &data->header)) {
+	stm32prog_header_check((struct raw_header_s *)addr, &data->header);
+	if (data->header.type == HEADER_STM32IMAGE) {
 		u32 checksum;
 
 		addr = addr + BL_HEADER_SIZE;
@@ -768,9 +787,8 @@ static int init_device(struct stm32prog_data *data,
 			part_found = true;
 		}
 
+		/* no partition for this device */
 		if (!part_found) {
-			stm32prog_err("%s (0x%x): Invalid partition",
-				      part->name, part->id);
 			pr_debug("\n");
 			continue;
 		}
@@ -804,7 +822,9 @@ static int treat_partition_list(struct stm32prog_data *data)
 		INIT_LIST_HEAD(&data->dev[j].part_list);
 	}
 
+#ifdef CONFIG_STM32MP15x_STM32IMAGE
 	data->tee_detected = false;
+#endif
 	data->fsbl_nor_detected = false;
 	for (i = 0; i < data->part_nb; i++) {
 		part = &data->part_array[i];
@@ -858,10 +878,12 @@ static int treat_partition_list(struct stm32prog_data *data)
 			/* fallthrough */
 		case STM32PROG_NAND:
 		case STM32PROG_SPI_NAND:
+#ifdef CONFIG_STM32MP15x_STM32IMAGE
 			if (!data->tee_detected &&
 			    !strncmp(part->name, "tee", 3))
 				data->tee_detected = true;
 			break;
+#endif
 		default:
 			break;
 		}
@@ -1410,7 +1432,7 @@ static int stm32prog_copy_fsbl(struct stm32prog_part_t *part)
 
 	if (part->target != STM32PROG_NAND &&
 	    part->target != STM32PROG_SPI_NAND)
-		return -1;
+		return -EINVAL;
 
 	dfu = dfu_get_entity(part->alt_id);
 
@@ -1420,8 +1442,10 @@ static int stm32prog_copy_fsbl(struct stm32prog_part_t *part)
 	ret = dfu->read_medium(dfu, 0, (void *)&raw_header, &size);
 	if (ret)
 		return ret;
-	if (stm32prog_header_check(&raw_header, &header))
-		return -1;
+
+	stm32prog_header_check(&raw_header, &header);
+	if (header.type != HEADER_STM32IMAGE)
+		return -ENOENT;
 
 	/* read header + payload */
 	size = header.image_length + BL_HEADER_SIZE;
diff --git a/arch/arm/mach-stm32mp/cmd_stm32prog/stm32prog.h b/arch/arm/mach-stm32mp/cmd_stm32prog/stm32prog.h
index bae4e91c01..fadcd1fa8f 100644
--- a/arch/arm/mach-stm32mp/cmd_stm32prog/stm32prog.h
+++ b/arch/arm/mach-stm32mp/cmd_stm32prog/stm32prog.h
@@ -37,8 +37,14 @@ enum stm32prog_link_t {
 	LINK_UNDEFINED,
 };
 
+enum stm32prog_header_t {
+	HEADER_NONE,
+	HEADER_STM32IMAGE,
+	HEADER_FIP,
+};
+
 struct image_header_s {
-	bool	present;
+	enum stm32prog_header_t type;
 	u32	image_checksum;
 	u32	image_length;
 };
@@ -115,7 +121,9 @@ struct stm32prog_data {
 	struct stm32prog_dev_t	dev[STM32PROG_MAX_DEV];	/* array of device */
 	int			part_nb;	/* nb of partition */
 	struct stm32prog_part_t	*part_array;	/* array of partition */
+#ifdef CONFIG_STM32MP15x_STM32IMAGE
 	bool			tee_detected;
+#endif
 	bool			fsbl_nor_detected;
 
 	/* command internal information */
@@ -160,8 +168,8 @@ int stm32prog_pmic_read(struct stm32prog_data *data, u32 offset,
 int stm32prog_pmic_start(struct stm32prog_data *data);
 
 /* generic part*/
-u8 stm32prog_header_check(struct raw_header_s *raw_header,
-			  struct image_header_s *header);
+void stm32prog_header_check(struct raw_header_s *raw_header,
+			    struct image_header_s *header);
 int stm32prog_dfu_init(struct stm32prog_data *data);
 void stm32prog_next_phase(struct stm32prog_data *data);
 void stm32prog_do_reset(struct stm32prog_data *data);
@@ -177,9 +185,29 @@ char *stm32prog_get_error(struct stm32prog_data *data);
 
 /* Main function */
 int stm32prog_init(struct stm32prog_data *data, ulong addr, ulong size);
+void stm32prog_clean(struct stm32prog_data *data);
+
+#ifdef CONFIG_CMD_STM32PROG_SERIAL
 int stm32prog_serial_init(struct stm32prog_data *data, int link_dev);
 bool stm32prog_serial_loop(struct stm32prog_data *data);
+#else
+static inline int stm32prog_serial_init(struct stm32prog_data *data, int link_dev)
+{
+	return -ENOSYS;
+}
+static inline bool stm32prog_serial_loop(struct stm32prog_data *data)
+{
+	return false;
+}
+#endif
+
+#ifdef CONFIG_CMD_STM32PROG_USB
 bool stm32prog_usb_loop(struct stm32prog_data *data, int dev);
-void stm32prog_clean(struct stm32prog_data *data);
+#else
+static inline bool stm32prog_usb_loop(struct stm32prog_data *data, int dev)
+{
+	return false;
+}
+#endif
 
 #endif
diff --git a/arch/arm/mach-stm32mp/cmd_stm32prog/stm32prog_serial.c b/arch/arm/mach-stm32mp/cmd_stm32prog/stm32prog_serial.c
index 8aad4be467..0c3c215b3d 100644
--- a/arch/arm/mach-stm32mp/cmd_stm32prog/stm32prog_serial.c
+++ b/arch/arm/mach-stm32mp/cmd_stm32prog/stm32prog_serial.c
@@ -186,36 +186,19 @@ static int stm32prog_read(struct stm32prog_data *data, u8 phase, u32 offset,
 int stm32prog_serial_init(struct stm32prog_data *data, int link_dev)
 {
 	struct udevice *dev = NULL;
-	int node;
-	char alias[10];
-	const char *path;
 	struct dm_serial_ops *ops;
 	/* no parity, 8 bits, 1 stop */
 	u32 serial_config = SERIAL_DEFAULT_CONFIG;
 
 	down_serial_dev = NULL;
 
-	sprintf(alias, "serial%d", link_dev);
-	path = fdt_get_alias(gd->fdt_blob, alias);
-	if (!path) {
-		pr_err("%s alias not found", alias);
-		return -ENODEV;
-	}
-	node = fdt_path_offset(gd->fdt_blob, path);
-	if (!uclass_get_device_by_of_offset(UCLASS_SERIAL, node,
-					    &dev)) {
-		down_serial_dev = dev;
-	} else if (node > 0 &&
-		   !lists_bind_fdt(gd->dm_root, offset_to_ofnode(node),
-				   &dev, false)) {
-		if (!device_probe(dev))
-			down_serial_dev = dev;
-	}
-	if (!down_serial_dev) {
-		pr_err("%s = %s device not found", alias, path);
+	if (uclass_get_device_by_seq(UCLASS_SERIAL, link_dev, &dev)) {
+		pr_err("serial %d device not found\n", link_dev);
 		return -ENODEV;
 	}
 
+	down_serial_dev = dev;
+
 	/* force silent console on uart only when used */
 	if (gd->cur_serial_dev == down_serial_dev)
 		gd->flags |= GD_FLG_DISABLE_CONSOLE | GD_FLG_SILENT;
@@ -225,11 +208,11 @@ int stm32prog_serial_init(struct stm32prog_data *data, int link_dev)
 	ops = serial_get_ops(down_serial_dev);
 
 	if (!ops) {
-		pr_err("%s = %s missing ops", alias, path);
+		pr_err("serial %d = %s missing ops\n", link_dev, dev->name);
 		return -ENODEV;
 	}
 	if (!ops->setconfig) {
-		pr_err("%s = %s missing setconfig", alias, path);
+		pr_err("serial %d = %s missing setconfig\n", link_dev, dev->name);
 		return -ENODEV;
 	}
 
@@ -325,11 +308,10 @@ static u8 stm32prog_header(struct stm32prog_data *data)
 	/* force cleanup to avoid issue with previous read */
 	dfu_transaction_cleanup(dfu_entity);
 
-	ret = stm32prog_header_check(data->header_data,
-				     &data->header);
+	stm32prog_header_check(data->header_data, &data->header);
 
-	/* no header : max size is partition size */
-	if (ret) {
+	/* no stm32 image header : max size is partition size */
+	if (data->header.type != HEADER_STM32IMAGE) {
 		dfu_entity->get_medium_size(dfu_entity, &size);
 		data->header.image_length = size;
 	}
@@ -397,16 +379,15 @@ static u8 stm32prog_start(struct stm32prog_data *data, u32 address)
 		if (!dfu_entity)
 			return -ENODEV;
 
-		if (data->dfu_seq) {
-			ret = dfu_flush(dfu_entity, NULL, 0, data->dfu_seq);
-			data->dfu_seq = 0;
-			if (ret) {
-				stm32prog_err("DFU flush failed [%d]", ret);
-				return ret;
-			}
+		ret = dfu_flush(dfu_entity, NULL, 0, data->dfu_seq);
+		if (ret) {
+			stm32prog_err("DFU flush failed [%d]", ret);
+			return ret;
 		}
+		data->dfu_seq = 0;
+
 		printf("\n  received length = 0x%x\n", data->cursor);
-		if (data->header.present) {
+		if (data->header.type == HEADER_STM32IMAGE) {
 			if (data->cursor !=
 			    (data->header.image_length + BL_HEADER_SIZE)) {
 				stm32prog_err("transmission interrupted (length=0x%x expected=0x%x)",
@@ -806,7 +787,7 @@ static void download_command(struct stm32prog_data *data)
 		}
 	}
 
-	if (image_header->present) {
+	if (data->header.type == HEADER_STM32IMAGE) {
 		if (data->cursor <= BL_HEADER_SIZE)
 			goto end;
 		/* compute checksum on payload */
diff --git a/arch/arm/mach-stm32mp/config.mk b/arch/arm/mach-stm32mp/config.mk
index c30bf482f7..f7f5b77c41 100644
--- a/arch/arm/mach-stm32mp/config.mk
+++ b/arch/arm/mach-stm32mp/config.mk
@@ -4,7 +4,7 @@
 #
 
 ifndef CONFIG_SPL
-INPUTS-y += u-boot.stm32
+INPUTS-$(CONFIG_STM32MP15x_STM32IMAGE) += u-boot.stm32
 else
 ifdef CONFIG_SPL_BUILD
 INPUTS-y += u-boot-spl.stm32
diff --git a/arch/arm/mach-stm32mp/cpu.c b/arch/arm/mach-stm32mp/cpu.c
index f19e5c3f33..b81825a0bf 100644
--- a/arch/arm/mach-stm32mp/cpu.c
+++ b/arch/arm/mach-stm32mp/cpu.c
@@ -219,18 +219,21 @@ static void early_enable_caches(void)
 	if (CONFIG_IS_ENABLED(SYS_DCACHE_OFF))
 		return;
 
+#if !(CONFIG_IS_ENABLED(SYS_ICACHE_OFF) && CONFIG_IS_ENABLED(SYS_DCACHE_OFF))
 	gd->arch.tlb_size = PGTABLE_SIZE;
 	gd->arch.tlb_addr = (unsigned long)&early_tlb;
+#endif
 
 	dcache_enable();
 
 	if (IS_ENABLED(CONFIG_SPL_BUILD))
 		mmu_set_region_dcache_behaviour(
-			ALIGN(STM32_SYSRAM_BASE, MMU_SECTION_SIZE),
-			round_up(STM32_SYSRAM_SIZE, MMU_SECTION_SIZE),
+			ALIGN_DOWN(STM32_SYSRAM_BASE, MMU_SECTION_SIZE),
+			ALIGN(STM32_SYSRAM_SIZE, MMU_SECTION_SIZE),
 			DCACHE_DEFAULT_OPTION);
 	else
-		mmu_set_region_dcache_behaviour(STM32_DDR_BASE, STM32_DDR_SIZE,
+		mmu_set_region_dcache_behaviour(STM32_DDR_BASE,
+						CONFIG_DDR_CACHEABLE_SIZE,
 						DCACHE_DEFAULT_OPTION);
 }
 
@@ -260,7 +263,8 @@ int arch_cpu_init(void)
 
 	boot_mode = get_bootmode();
 
-	if ((boot_mode & TAMP_BOOT_DEVICE_MASK) == BOOT_SERIAL_UART)
+	if (IS_ENABLED(CONFIG_CMD_STM32PROG_SERIAL) &&
+	    (boot_mode & TAMP_BOOT_DEVICE_MASK) == BOOT_SERIAL_UART)
 		gd->flags |= GD_FLG_SILENT | GD_FLG_DISABLE_CONSOLE;
 #if defined(CONFIG_DEBUG_UART) && \
 	!defined(CONFIG_TFABOOT) && \
@@ -460,7 +464,6 @@ static void setup_boot_mode(void)
 	unsigned int instance = (boot_mode & TAMP_BOOT_INSTANCE_MASK) - 1;
 	u32 forced_mode = (boot_ctx & TAMP_BOOT_FORCED_MASK);
 	struct udevice *dev;
-	int alias;
 
 	pr_debug("%s: boot_ctx=0x%x => boot_mode=%x, instance=%d forced=%x\n",
 		 __func__, boot_ctx, boot_mode, instance, forced_mode);
@@ -470,17 +473,22 @@ static void setup_boot_mode(void)
 			break;
 		/* serial : search associated alias in devicetree */
 		sprintf(cmd, "serial@%x", serial_addr[instance]);
-		if (uclass_get_device_by_name(UCLASS_SERIAL, cmd, &dev))
-			break;
-		if (fdtdec_get_alias_seq(gd->fdt_blob, "serial",
-					 dev_of_offset(dev), &alias))
+		if (uclass_get_device_by_name(UCLASS_SERIAL, cmd, &dev)) {
+			/* restore console on error */
+			if (IS_ENABLED(CONFIG_CMD_STM32PROG_SERIAL))
+				gd->flags &= ~(GD_FLG_SILENT |
+					       GD_FLG_DISABLE_CONSOLE);
+			printf("uart%d = %s not found in device tree!\n",
+			       instance, cmd);
 			break;
-		sprintf(cmd, "%d", alias);
+		}
+		sprintf(cmd, "%d", dev->seq);
 		env_set("boot_device", "serial");
 		env_set("boot_instance", cmd);
 
 		/* restore console on uart when not used */
-		if (gd->cur_serial_dev != dev) {
+		if (IS_ENABLED(CONFIG_CMD_STM32PROG_SERIAL) &&
+		    (gd->cur_serial_dev != dev)) {
 			gd->flags &= ~(GD_FLG_SILENT |
 				       GD_FLG_DISABLE_CONSOLE);
 			printf("serial boot with console enabled!\n");
diff --git a/arch/arm/mach-stm32mp/fdt.c b/arch/arm/mach-stm32mp/fdt.c
index 0de1d82291..cfaac8a416 100644
--- a/arch/arm/mach-stm32mp/fdt.c
+++ b/arch/arm/mach-stm32mp/fdt.c
@@ -328,7 +328,16 @@ int ft_system_setup(void *blob, struct bd_info *bd)
 				       "st,package", pkg, false);
 	}
 
-	if (!CONFIG_IS_ENABLED(OPTEE) ||
+	/*
+	 * TEMP: remove OP-TEE nodes in kernel device tree
+	 *       copied from U-Boot device tree by optee_copy_fdt_nodes
+	 *       when OP-TEE is not detected (probe failed)
+	 * these OP-TEE nodes are present in <board>-u-boot.dtsi
+	 * under CONFIG_STM32MP15x_STM32IMAGE only for compatibility
+	 * when FIP is not used by TF-A
+	 */
+	if (CONFIG_IS_ENABLED(STM32MP15x_STM32IMAGE) &&
+	    CONFIG_IS_ENABLED(OPTEE) &&
 	    !tee_find_device(NULL, NULL, NULL, NULL))
 		stm32_fdt_disable_optee(blob);
 
diff --git a/arch/arm/mach-stm32mp/include/mach/stm32.h b/arch/arm/mach-stm32mp/include/mach/stm32.h
index 5fdb893b0e..af7ccdcc48 100644
--- a/arch/arm/mach-stm32mp/include/mach/stm32.h
+++ b/arch/arm/mach-stm32mp/include/mach/stm32.h
@@ -91,8 +91,10 @@ enum boot_device {
 
 /* TAMP registers */
 #define TAMP_BACKUP_REGISTER(x)		(STM32_TAMP_BASE + 0x100 + 4 * x)
+/* secure access */
 #define TAMP_BACKUP_MAGIC_NUMBER	TAMP_BACKUP_REGISTER(4)
 #define TAMP_BACKUP_BRANCH_ADDRESS	TAMP_BACKUP_REGISTER(5)
+/* non secure access */
 #define TAMP_COPRO_RSC_TBL_ADDRESS	TAMP_BACKUP_REGISTER(17)
 #define TAMP_COPRO_STATE		TAMP_BACKUP_REGISTER(18)
 #define TAMP_BOOT_CONTEXT		TAMP_BACKUP_REGISTER(20)
diff --git a/arch/arm/mach-stm32mp/include/mach/stm32mp1_smc.h b/arch/arm/mach-stm32mp/include/mach/stm32mp1_smc.h
index 4ad14f963b..d72747ca31 100644
--- a/arch/arm/mach-stm32mp/include/mach/stm32mp1_smc.h
+++ b/arch/arm/mach-stm32mp/include/mach/stm32mp1_smc.h
@@ -8,19 +8,53 @@
 
 #include <linux/arm-smccc.h>
 
+/* SMC service generic return codes */
+#define STM32_SMC_OK			0x00000000U
+#define STM32_SMC_NOT_SUPPORTED		0xFFFFFFFFU
+#define STM32_SMC_FAILED		0xFFFFFFFEU
+#define STM32_SMC_INVALID_PARAMS	0xFFFFFFFDU
+
 /*
- * SMC function IDs for STM32 Service queries
+ * SMC function IDs for STM32 Service queries.
  * STM32 SMC services use the space between 0x82000000 and 0x8200FFFF
  * like this is defined in SMC calling Convention by ARM
- * for SiP (silicon Partner)
- * http://infocenter.arm.com/help/topic/com.arm.doc.den0028a/index.html
+ * for SiP (silicon Partner).
+ * https://developer.arm.com/docs/den0028/latest
  */
-#define STM32_SMC_VERSION		0x82000000
 
 /* Secure Service access from Non-secure */
+
+/*
+ * SMC function STM32_SMC_PWR.
+ *
+ * Argument a0: (input) SMCC ID.
+ *		(output) Status return code.
+ * Argument a1: (input) Service ID (STM32_SMC_REG_xxx).
+ * Argument a2: (input) Register offset or physical address.
+ *		(output) Register read value, if applicable.
+ * Argument a3: (input) Register target value if applicable.
+ */
+#define STM32_SMC_PWR			0x82001001
+
+/*
+ * SMC functions STM32_SMC_BSEC.
+ *
+ * Argument a0: (input) SMCC ID.
+ *		(output) Status return code.
+ * Argument a1: (input) Service ID (STM32_SMC_READ_xxx/_PROG_xxx/_WRITE_xxx).
+ *		(output) OTP read value, if applicable.
+ * Argument a2: (input) OTP index.
+ * Argument a3: (input) OTP value if applicable.
+ */
 #define STM32_SMC_BSEC			0x82001003
 
-/* Service for BSEC */
+/* Service ID for STM32_SMC_PWR */
+#define STM32_SMC_REG_READ		0x0
+#define STM32_SMC_REG_WRITE		0x1
+#define STM32_SMC_REG_SET		0x2
+#define STM32_SMC_REG_CLEAR		0x3
+
+/* Service ID for STM32_SMC_BSEC */
 #define STM32_SMC_READ_SHADOW		0x01
 #define STM32_SMC_PROG_OTP		0x02
 #define STM32_SMC_WRITE_SHADOW		0x03
@@ -29,12 +63,6 @@
 #define STM32_SMC_WRITE_ALL		0x06
 #define STM32_SMC_WRLOCK_OTP		0x07
 
-/* SMC error codes */
-#define STM32_SMC_OK			0x0
-#define STM32_SMC_NOT_SUPPORTED		-1
-#define STM32_SMC_FAILED		-2
-#define STM32_SMC_INVALID_PARAMS	-3
-
 #define stm32_smc_exec(svc, op, data1, data2) \
 	stm32_smc(svc, op, data1, data2, NULL)
 
diff --git a/arch/arm/mach-stm32mp/include/mach/stm32prog.h b/arch/arm/mach-stm32mp/include/mach/stm32prog.h
index c080b9cc42..241eec48d5 100644
--- a/arch/arm/mach-stm32mp/include/mach/stm32prog.h
+++ b/arch/arm/mach-stm32mp/include/mach/stm32prog.h
@@ -11,6 +11,7 @@ int stm32prog_read_medium_virt(struct dfu_entity *dfu, u64 offset,
 			       void *buf, long *len);
 int stm32prog_get_medium_size_virt(struct dfu_entity *dfu, u64 *size);
 
+/* only needed for CONFIG_STM32MP15x_STM32IMAGE, prototype defined to avoid compilation issue */
 bool stm32prog_get_tee_partitions(void);
 
 bool stm32prog_get_fsbl_nor(void);
diff --git a/arch/arm/mach-stm32mp/pwr_regulator.c b/arch/arm/mach-stm32mp/pwr_regulator.c
index 900dee4c38..1fbd180990 100644
--- a/arch/arm/mach-stm32mp/pwr_regulator.c
+++ b/arch/arm/mach-stm32mp/pwr_regulator.c
@@ -8,6 +8,7 @@
 #include <errno.h>
 #include <syscon.h>
 #include <asm/io.h>
+#include <asm/arch/stm32mp1_smc.h>
 #include <dm/device_compat.h>
 #include <linux/bitops.h>
 #include <linux/err.h>
@@ -41,6 +42,10 @@ static int stm32mp_pwr_write(struct udevice *dev, uint reg,
 	if (len != 4)
 		return -EINVAL;
 
+	if (IS_ENABLED(CONFIG_TFABOOT))
+		return stm32_smc_exec(STM32_SMC_PWR, STM32_SMC_REG_WRITE,
+				      STM32MP_PWR_CR3, val);
+
 	writel(val, priv->base + STM32MP_PWR_CR3);
 
 	return 0;
diff --git a/arch/arm/mach-stm32mp/spl.c b/arch/arm/mach-stm32mp/spl.c
index e84bdad7bf..66a634654e 100644
--- a/arch/arm/mach-stm32mp/spl.c
+++ b/arch/arm/mach-stm32mp/spl.c
@@ -55,6 +55,7 @@ u32 spl_mmc_boot_mode(const u32 boot_device)
 	return MMCSD_MODE_RAW;
 }
 
+#ifdef CONFIG_SYS_MMCSD_RAW_MODE_U_BOOT_USE_PARTITION
 int spl_mmc_boot_partition(const u32 boot_device)
 {
 	switch (boot_device) {
@@ -66,6 +67,7 @@ int spl_mmc_boot_partition(const u32 boot_device)
 		return -EINVAL;
 	}
 }
+#endif
 
 #ifdef CONFIG_SPL_DISPLAY_PRINT
 void spl_display_print(void)
@@ -138,7 +140,8 @@ void board_init_f(ulong dummy)
 	 * to avoid speculative access and issue in get_ram_size()
 	 */
 	if (!CONFIG_IS_ENABLED(SYS_DCACHE_OFF))
-		mmu_set_region_dcache_behaviour(STM32_DDR_BASE, STM32_DDR_SIZE,
+		mmu_set_region_dcache_behaviour(STM32_DDR_BASE,
+						CONFIG_DDR_CACHEABLE_SIZE,
 						DCACHE_DEFAULT_OPTION);
 }
 
diff --git a/arch/m68k/include/asm/config.h b/arch/m68k/include/asm/config.h
index c7363c0b51..b692cc9202 100644
--- a/arch/m68k/include/asm/config.h
+++ b/arch/m68k/include/asm/config.h
@@ -8,7 +8,6 @@
 
 #define CONFIG_NEEDS_MANUAL_RELOC
 
-#define CONFIG_LMB
 #define CONFIG_SYS_BOOT_RAMDISK_HIGH
 
 #endif
diff --git a/arch/microblaze/include/asm/config.h b/arch/microblaze/include/asm/config.h
index 1124272915..e65e3649fe 100644
--- a/arch/microblaze/include/asm/config.h
+++ b/arch/microblaze/include/asm/config.h
@@ -6,8 +6,6 @@
 #ifndef _ASM_CONFIG_H_
 #define _ASM_CONFIG_H_
 
-#define CONFIG_LMB
-
 #ifndef CONFIG_SPL_BUILD
 #define CONFIG_NEEDS_MANUAL_RELOC
 #endif
diff --git a/arch/mips/include/asm/config.h b/arch/mips/include/asm/config.h
index 7ea443673a..221eb93d58 100644
--- a/arch/mips/include/asm/config.h
+++ b/arch/mips/include/asm/config.h
@@ -6,7 +6,6 @@
 #ifndef _ASM_CONFIG_H_
 #define _ASM_CONFIG_H_
 
-#define CONFIG_LMB
 #define CONFIG_SYS_BOOT_RAMDISK_HIGH
 
 #endif
diff --git a/arch/nds32/include/asm/config.h b/arch/nds32/include/asm/config.h
index 8964a58f27..6c1cbce7ef 100644
--- a/arch/nds32/include/asm/config.h
+++ b/arch/nds32/include/asm/config.h
@@ -7,6 +7,5 @@
 
 #ifndef _ASM_CONFIG_H_
 #define _ASM_CONFIG_H_
-#define CONFIG_LMB
 
 #endif
diff --git a/arch/powerpc/include/asm/config.h b/arch/powerpc/include/asm/config.h
index c9c9964630..99b410dc9b 100644
--- a/arch/powerpc/include/asm/config.h
+++ b/arch/powerpc/include/asm/config.h
@@ -18,7 +18,6 @@
   #define HWCONFIG_BUFFER_SIZE 256
 #endif
 
-#define CONFIG_LMB
 #define CONFIG_SYS_BOOT_RAMDISK_HIGH
 
 #ifndef CONFIG_MAX_MEM_MAPPED
diff --git a/arch/riscv/include/asm/config.h b/arch/riscv/include/asm/config.h
index 156cb94dc0..d911007537 100644
--- a/arch/riscv/include/asm/config.h
+++ b/arch/riscv/include/asm/config.h
@@ -7,7 +7,6 @@
 #ifndef _ASM_CONFIG_H_
 #define _ASM_CONFIG_H_
 
-#define CONFIG_LMB
 #define CONFIG_SYS_BOOT_RAMDISK_HIGH
 
 #endif
diff --git a/arch/riscv/lib/fdt_fixup.c b/arch/riscv/lib/fdt_fixup.c
index 5b2420243f..d02062fd5b 100644
--- a/arch/riscv/lib/fdt_fixup.c
+++ b/arch/riscv/lib/fdt_fixup.c
@@ -75,7 +75,7 @@ int riscv_fdt_copy_resv_mem_node(const void *src, void *dst)
 		pmp_mem.start = addr;
 		pmp_mem.end = addr + size - 1;
 		err = fdtdec_add_reserved_memory(dst, basename, &pmp_mem,
-						 &phandle);
+						 &phandle, false);
 		if (err < 0 && err != -FDT_ERR_EXISTS) {
 			log_err("failed to add reserved memory: %d\n", err);
 			return err;
diff --git a/arch/sandbox/dts/test.dts b/arch/sandbox/dts/test.dts
index 9f45c48e4e..7023f33a67 100644
--- a/arch/sandbox/dts/test.dts
+++ b/arch/sandbox/dts/test.dts
@@ -356,6 +356,37 @@
 		sandbox_firmware: sandbox-firmware {
 			compatible = "sandbox,firmware";
 		};
+
+		sandbox-scmi-agent@0 {
+			compatible = "sandbox,scmi-agent";
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			clk_scmi0: protocol@14 {
+				reg = <0x14>;
+				#clock-cells = <1>;
+			};
+
+			reset_scmi0: protocol@16 {
+				reg = <0x16>;
+				#reset-cells = <1>;
+			};
+		};
+
+		sandbox-scmi-agent@1 {
+			compatible = "sandbox,scmi-agent";
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			clk_scmi1: protocol@14 {
+				reg = <0x14>;
+				#clock-cells = <1>;
+			};
+
+			protocol@10 {
+				reg = <0x10>;
+			};
+		};
 	};
 
 	pinctrl-gpio {
@@ -1036,6 +1067,12 @@
 		compatible = "sandbox,virtio2";
 	};
 
+	sandbox_scmi {
+		compatible = "sandbox,scmi-devices";
+		clocks = <&clk_scmi0 7>, <&clk_scmi0 3>, <&clk_scmi1 1>;
+		resets = <&reset_scmi0 3>;
+	};
+
 	pinctrl {
 		compatible = "sandbox,pinctrl";
 
diff --git a/arch/sandbox/include/asm/scmi_test.h b/arch/sandbox/include/asm/scmi_test.h
new file mode 100644
index 0000000000..3e8b0068fd
--- /dev/null
+++ b/arch/sandbox/include/asm/scmi_test.h
@@ -0,0 +1,99 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (C) 2020, Linaro Limited
+ */
+
+#ifndef __SANDBOX_SCMI_TEST_H
+#define __SANDBOX_SCMI_TEST_H
+
+struct udevice;
+struct sandbox_scmi_agent;
+struct sandbox_scmi_service;
+
+/**
+ * struct sandbox_scmi_clk - Simulated clock exposed by SCMI
+ * @id:		Identifier of the clock used in the SCMI protocol
+ * @enabled:	Clock state: true if enabled, false if disabled
+ * @rate:	Clock rate in Hertz
+ */
+struct sandbox_scmi_clk {
+	uint id;
+	bool enabled;
+	ulong rate;
+};
+
+/**
+ * struct sandbox_scmi_reset - Simulated reset controller exposed by SCMI
+ * @asserted:	Reset control state: true if asserted, false if desasserted
+ */
+struct sandbox_scmi_reset {
+	uint id;
+	bool asserted;
+};
+
+/**
+ * struct sandbox_scmi_agent - Simulated SCMI service seen by SCMI agent
+ * @idx:	Identifier for the SCMI agent, its index
+ * @clk:	Simulated clocks
+ * @clk_count:	Simulated clocks array size
+ * @clk:	Simulated reset domains
+ * @clk_count:	Simulated reset domains array size
+ */
+struct sandbox_scmi_agent {
+	uint idx;
+	struct sandbox_scmi_clk *clk;
+	size_t clk_count;
+	struct sandbox_scmi_reset *reset;
+	size_t reset_count;
+};
+
+/**
+ * struct sandbox_scmi_service - Reference to simutaed SCMI agents/services
+ * @agent:		Pointer to SCMI sandbox agent pointers array
+ * @agent_count:	Number of emulated agents exposed in array @agent.
+ */
+struct sandbox_scmi_service {
+	struct sandbox_scmi_agent **agent;
+	size_t agent_count;
+};
+
+/**
+ * struct sandbox_scmi_devices - Reference to devices probed through SCMI
+ * @clk:		Array the clock devices
+ * @clk_count:		Number of clock devices probed
+ * @reset:		Array the reset controller devices
+ * @reset_count:	Number of reset controller devices probed
+ */
+struct sandbox_scmi_devices {
+	struct clk *clk;
+	size_t clk_count;
+	struct reset_ctl *reset;
+	size_t reset_count;
+};
+
+#ifdef CONFIG_SCMI_FIRMWARE
+/**
+ * sandbox_scmi_service_context - Get the simulated SCMI services context
+ * @return:	Reference to backend simulated resources state
+ */
+struct sandbox_scmi_service *sandbox_scmi_service_ctx(void);
+
+/**
+ * sandbox_scmi_devices_get_ref - Get references to devices accessed through SCMI
+ * @dev:	Reference to the test device used get test resources
+ * @return:	Reference to the devices probed by the SCMI test
+ */
+struct sandbox_scmi_devices *sandbox_scmi_devices_ctx(struct udevice *dev);
+#else
+static inline struct sandbox_scmi_service *sandbox_scmi_service_ctx(void)
+{
+	return NULL;
+}
+
+static inline
+struct sandbox_scmi_devices *sandbox_scmi_devices_ctx(struct udevice *dev)
+{
+	return NULL;
+}
+#endif /* CONFIG_SCMI_FIRMWARE */
+#endif /* __SANDBOX_SCMI_TEST_H */
diff --git a/arch/sh/include/asm/config.h b/arch/sh/include/asm/config.h
index e1cd322152..406156dff5 100644
--- a/arch/sh/include/asm/config.h
+++ b/arch/sh/include/asm/config.h
@@ -8,8 +8,6 @@
 
 #include <asm/processor.h>
 
-#define CONFIG_LMB
-
 /* Timer */
 #define CONFIG_SYS_TIMER_COUNTS_DOWN
 #define CONFIG_SYS_TIMER_COUNTER	(TMU_BASE + 0xc)	/* TCNT0 */
diff --git a/arch/x86/include/asm/config.h b/arch/x86/include/asm/config.h
index 7ea443673a..221eb93d58 100644
--- a/arch/x86/include/asm/config.h
+++ b/arch/x86/include/asm/config.h
@@ -6,7 +6,6 @@
 #ifndef _ASM_CONFIG_H_
 #define _ASM_CONFIG_H_
 
-#define CONFIG_LMB
 #define CONFIG_SYS_BOOT_RAMDISK_HIGH
 
 #endif
diff --git a/arch/xtensa/include/asm/config.h b/arch/xtensa/include/asm/config.h
index 5a95fc93f7..a1096ab196 100644
--- a/arch/xtensa/include/asm/config.h
+++ b/arch/xtensa/include/asm/config.h
@@ -9,8 +9,6 @@
 
 #include <asm/arch/core.h>
 
-#define CONFIG_LMB
-
 /*
  * Make boot parameters available in the MMUv2 virtual memory layout by
  * restricting used physical memory to the first 128MB.
-- 
2.17.1

